<!-- Portfolio Zone -->
<div class="portfolio-wrapper" id="portfolioWrapper" aria-live="polite">
  <!-- Tiles will be injected here from JSON -->
</div>

<style>
:root{
  --pz-ease: cubic-bezier(.22,.61,.36,1);
  --pz-grow-dur: 900ms;   /* slow/visible grow */
  --pz-slide-dur: 520ms;  /* clear slide-left */
  --tile-gap: 2rem;
}

/* 3-across desktop grid via flex */
.portfolio-wrapper{
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  gap: var(--tile-gap);
  align-items: flex-start;
  position: relative;
}

.portfolio-tile{
  position: relative;
  flex: 0 1 28%;           /* ~3 across with gap */
  cursor: pointer;
  border-radius: 10px;
  overflow: hidden;
  isolation: isolate;
}
.portfolio-tile:focus-visible{ box-shadow: 0 0 0 3px #4F8ABA; outline: none; }

.portfolio-preview-img{
  display: block;
  width: 100%;
  height: auto;
}

/* Top-row placeholder reserves the expanded row HEIGHT at the very top,
   so ALL tiles immediately drop below on click. */
.toprow-placeholder{
  flex: 0 0 100%;
  height: var(--ph-height, 0px);
  pointer-events: none;
  order: -1000; /* sit at the very top row in flex flow */
}

/* Fixed overlay that animates independently of layout (no jank) */
.overlay-anim{
  position: fixed;
  left: 0; top: 0;
  width: 0; height: 0;
  border-radius: 10px;
  overflow: hidden;
  z-index: 9999;
  pointer-events: none;
  will-change: left, top, width, height;
  background: #0000; /* transparent */
}
.overlay-anim img{
  display: block;
  width: 100%;
  height: auto;
}

/* Helper message if viewport isn’t desktop (optional) */
@media (max-width: 1023.98px){
  .portfolio-wrapper::before{
    content: "Desktop demo: widen viewport ≥1024px to test this step.";
    display: block;
    width: 100%;
    color: #fff;
    background: rgba(0,0,0,.4);
    padding: .5rem .75rem;
    border-radius: 8px;
    margin-bottom: 1rem;
  }
}
</style>

<script>
(function(){
  const WRAPPER = document.getElementById('portfolioWrapper');
  const DATA_URL = 'assets/portfolio.json';  // [{ id, image, alt }]
  const EXPANDED_RATIO = 0.75;               // 75% of wrapper width
  let animBusy = false;
  let current = null;                        // currently expanded tile (real tile)
  let topRowPh = null;                       // the top-row placeholder element

  // Build a tile
  function makeTile(item){
    const el = document.createElement('article');
    el.className = 'portfolio-tile';
    el.setAttribute('tabindex','0');
    el.setAttribute('role','button');
    el.dataset.id = item.id;
    el.innerHTML = `
      <img class="portfolio-preview-img" src="${item.image}" alt="${item.alt || ''}" loading="lazy" decoding="async">
    `;
    el.addEventListener('click', () => expand(el));
    el.addEventListener('keydown', e => {
      if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); expand(el); }
    });
    return el;
  }

  const isDesktop = () => window.matchMedia('(min-width: 1024px)').matches;

  // Row position (left / center / right) where the tile is *currently* displayed
  function getRowPos(tile){
    const tiles = [...WRAPPER.querySelectorAll('.portfolio-tile')];
    const eps = 4;
    const rows = [];
    tiles.forEach(t=>{
      const r = t.getBoundingClientRect();
      const top = Math.round(r.top);
      let row = rows.find(x => Math.abs(x.top - top) <= eps);
      if(!row){ row = { top, items: [] }; rows.push(row); }
      row.items.push({ el: t, rect: r });
    });
    rows.sort((a,b)=>a.top-b.top);
    const row = rows.find(r => r.items.some(x => x.el === tile));
    if(!row) return 'center';
    row.items.sort((a,b)=>a.rect.left-b.rect.left);
    const idx = row.items.findIndex(x => x.el === tile);
    if(idx === 0) return 'left';
    if(idx === row.items.length-1) return 'right';
    return 'center';
  }

  // Create the overlay clone **before** we touch DOM (to keep the true start rect)
  function cloneOverlayFrom(tile){
    const img = tile.querySelector('.portfolio-preview-img');
    const r = img.getBoundingClientRect();
    const overlay = document.createElement('div');
    overlay.className = 'overlay-anim';
    overlay.style.left   = r.left + 'px';
    overlay.style.top    = r.top  + 'px';
    overlay.style.width  = r.width + 'px';
    overlay.style.height = r.height + 'px';
    overlay.innerHTML = `<img src="${img.src}" alt="">`;
    document.body.appendChild(overlay);
    return { overlay, startRect: r };
  }

  // Ensure a single **top-row placeholder** that reserves final height.
  function ensureTopRowPlaceholder(heightPx){
    if (!topRowPh) {
      topRowPh = document.createElement('div');
      topRowPh.className = 'toprow-placeholder';
      WRAPPER.prepend(topRowPh); // always at the very top so *all* tiles sit below it
    }
    topRowPh.style.setProperty('--ph-height', heightPx + 'px');
  }

  function removeTopRowPlaceholder(){
    if(topRowPh){ topRowPh.remove(); topRowPh = null; }
  }

  // Expand
  function expand(tile){
    if(!isDesktop()) return;    // desktop focus for this step
    if(animBusy) return;
    animBusy = true;

    // Collapse any active (no reflowed animation needed)
    if(current && current !== tile){
      collapse(current, true);
    }
    current = tile;

    // 1) Measure start state **before** DOM changes
    const { overlay, startRect } = cloneOverlayFrom(tile);
    const wrapRect = WRAPPER.getBoundingClientRect();

    // Final width/height & top for the expanded overlay at the top row
    const targetW = Math.round(wrapRect.width * EXPANDED_RATIO);
    const targetH = Math.round(startRect.height * (targetW / startRect.width));
    const targetTop = wrapRect.top;             // expanded row’s top (viewport coords)

    // Compute left anchoring during the grow phase (based on where the tile lives now)
    const pos = getRowPos(tile);                // 'left'|'center'|'right'
    const leftPositions = {
      left  : wrapRect.left,
      center: wrapRect.left + (wrapRect.width - targetW) / 2,
      right : wrapRect.left + (wrapRect.width - targetW)
    };

    // 2) Reserve the top row immediately so ALL tiles drop under it.
    ensureTopRowPlaceholder(targetH);

    // 3) Remove the clicked tile from flow to prevent a blank gap
    //    (preserves DOM order because we don't move it; just toggle display)
    tile.style.display = 'none';

    // 4) Phase A — grow overlay to 75% anchored by current pos, moving vertically to top row
    overlay.style.transition =
      `left var(--pz-grow-dur) var(--pz-ease),
       top var(--pz-grow-dur) var(--pz-ease),
       width var(--pz-grow-dur) var(--pz-ease),
       height var(--pz-grow-dur) var(--pz-ease)`;
    void overlay.offsetWidth; // reflow
    overlay.style.left   = leftPositions[pos] + 'px';
    overlay.style.top    = targetTop + 'px';
    overlay.style.width  = targetW + 'px';
    overlay.style.height = targetH + 'px';

    const onGrowEnd = (e)=>{
      if(e.propertyName !== 'width') return;
      overlay.removeEventListener('transitionend', onGrowEnd);

      // 5) Phase B — if started center or right, slide horizontally to left edge at the top row
      if(pos !== 'left'){
        overlay.style.transition = `left var(--pz-slide-dur) var(--pz-ease)`;
        void overlay.offsetWidth;
        overlay.style.left = wrapRect.left + 'px';
        overlay.addEventListener('transitionend', onSlideEnd);
      }else{
        onSlideEnd();
      }
    };

    const onSlideEnd = ()=>{
      overlay.removeEventListener('transitionend', onSlideEnd);
      // Keep overlay visible at the top as the expanded piece.
      // (Real tile remains hidden in original order.)

      animBusy = false;

      // Outside click collapses (capture to beat underlying tiles)
      const outsideClose = (ev)=>{
        if(ev.target.closest('.overlay-anim')) return;
        document.removeEventListener('click', outsideClose, true);
        collapse(current);
      };
      setTimeout(()=>document.addEventListener('click', outsideClose, true), 0);

      // store overlay ref for collapse
      tile._overlayRef = overlay;
    };

    overlay.addEventListener('transitionend', onGrowEnd);
  }

  // Collapse: remove overlay and placeholder, reveal original tile
  function collapse(tile, silent=false){
    const overlay = tile._overlayRef;
    if(overlay && overlay.parentNode){
      overlay.remove();
    }
    tile._overlayRef = null;

    // Reveal the original tile again (same DOM position/order)
    tile.style.display = '';

    removeTopRowPlaceholder();

    if(!silent) current = null;
    animBusy = false;
  }

  // ESC collapses
  document.addEventListener('keydown', (e)=>{
    if((e.key === 'Escape' || e.keyCode === 27) && current){
      collapse(current);
    }
  });

  // Init from JSON
  async function init(){
    try{
      const res = await fetch(DATA_URL, { cache:'no-store' });
      if(!res.ok) throw new Error(res.status);
      const data = await res.json();
      if(!Array.isArray(data)) throw new Error('JSON must be an array');
      data.forEach(item => WRAPPER.appendChild(makeTile(item)));
    }catch(err){
      console.error('[portfolio] JSON error:', err);
      // Fallback demo
      [
        { id:'a', image:'imgs/portfolio-previews/typezero.png',  alt:'TypeZero' },
        { id:'b', image:'imgs/portfolio-previews/typezero1.png', alt:'TypeZero 1' },
        { id:'c', image:'imgs/portfolio-previews/typezero2.jpg', alt:'TypeZero 2' }
      ].forEach(item => WRAPPER.appendChild(makeTile(item)));
    }
  }
  document.addEventListener('DOMContentLoaded', init);
})();
</script>
