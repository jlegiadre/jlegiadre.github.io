<style>
/* Root-level controls */
:root {
  /* Timings */
  --initial-delay: 0ms;        /* wait before the draw starts */
  --draw-duration: 2s;         /* speed of draw */
  --post-draw-delay: 400ms;    /* pause after draw */
  --push-duration: 1.6s;       /* speed of push */

  /* Easing */
  --draw-ease: cubic-bezier(0.42, 0, 1, 1);
  --push-ease: cubic-bezier(0.42, 0, 1, 1);

  /* Stroke visuals */
  --stroke-width: 47;
  --stroke-color: currentColor;

  /* Dash mechanics (pathLength="1" normalizes units) */
  --gap: 1000;                 /* huge gap => only one dash is ever visible */
  --push-distance: -1;         /* you said -1 was correct for your path direction */
  --overshoot: 0.02;           /* tiny extra push beyond the end (tweak 0.01–0.06) */
}

/* Attach this class to your <use> element (e.g., <use href="#p1" class="draw-then-push seg1"/>) */
svg .draw-then-push {
  stroke: var(--stroke-color);
  stroke-width: var(--stroke-width);
  stroke-linecap: round;
  fill: none;
  vector-effect: non-scaling-stroke;

  /* Start hidden: zero-length dash + huge gap */
  stroke-dasharray: 0 var(--gap);
  stroke-dashoffset: 0;

  /* draw → (pause) → push */
  animation:
    svg-stroke-draw var(--draw-duration) var(--draw-ease) var(--initial-delay) forwards,
    svg-stroke-push var(--push-duration) var(--push-ease)
      calc(var(--initial-delay) + var(--draw-duration) + var(--post-draw-delay)) forwards;

  will-change: stroke-dasharray, stroke-dashoffset;
}

/* Phase 1: Draw (grow a single dash from 0 → 1; gap stays huge so no repeats) */
@keyframes svg-stroke-draw {
  from { stroke-dasharray: 0 var(--gap); }
  to   { stroke-dasharray: 1 var(--gap); }
}

/* Phase 2: Push
   - First, slide the full-length dash off the end (to 1 * push-direction).
   - Then, during the final 20%, also shrink the dash to 0 and overshoot slightly.
   This eliminates the tiny residual you saw from round caps/AA. */
@keyframes svg-stroke-push {
  0% {
    stroke-dasharray: 1 var(--gap);
    stroke-dashoffset: 0;
  }
  80% {
    stroke-dasharray: 1 var(--gap);
    stroke-dashoffset: var(--push-distance);
  }
  100% {
    stroke-dasharray: 0 var(--gap); /* dash fully collapsed */
    stroke-dashoffset: calc(var(--push-distance) * (1 + var(--overshoot)));
  }
}

/* Optional: if you prefer a crisp cutoff at the tail,
   switch to square ends (comment out to keep round) */
/*
svg .draw-then-push { stroke-linecap: butt; }
*/

/* Reduced motion: show the final state instantly */
@media (prefers-reduced-motion: reduce) {
  svg .draw-then-push {
    animation: none;
    stroke-dasharray: 1 var(--gap);
    stroke-dashoffset: 0;
  }
}
</style>

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500" preserveAspectRatio="xMidYMid meet" aria-hidden="true" focusable="false">
  <defs>
	<!-- Centerline paths -->
	<path id="p1" pathLength="1" d="M161.6,181.1l40.3-38.4c53.8,223.9-4.5,308.4-60.3,317.8" />
	<!-- Outline clips -->
	<path id="op1" d="M206.5,141.6l-2.6-8.2c-13.8,15.3-29,32.1-42.3,47.7c11.8-9.2,24.8-19.6,36.9-29.4c12,77.8,25.2,192.4-15.6,259.2  c-10,16.4-25.9,30-44.2,33l5.8,33.2c18.1-3.2,35.1-12.3,48-25.7C263.1,377,234.5,229.5,206.5,141.6z" />

	<clipPath id="clip1" clipPathUnits="userSpaceOnUse"><use href="#op1"/></clipPath>
  </defs>

  <!-- Hidden until each segment’s reveal; no start flash, no endpoint flicker -->
  <g style="shape-rendering:geometricPrecision">
	<g clip-path="url(#clip1)">
		<use href="#p1" class="draw-then-push seg1"/>
	  </g>
  </g>
</svg>